---
title: "Multi-cytokine HRECs Markdown"
author: "Fergus McLellan"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Setup Work Space

To begin, I load tidyverse and run some code to clear my environment and set my desired information printing parameters

```{r}
library(tidyverse) #contains multiple packages for general tidiness
library(magrittr) #package adding useful functions for pipe operator
library(dtplyr) #package adding useful functions for pipe operator
library(textshaping) 

rm(list = ls(all.names = TRUE))
gc()
options(max.print = .Machine$integer.max, scipen = 999, stringsAsFactors = F, dplyr.summarise.inform = F)

set.seed(12345)
```

next, I set my and input/output paths

```{r}

in_path <- "raw_data/" #set input path from working directory
out_path = "significant_data/" # set output path from working directory

```

# Differential Expression Analysis

The following section will describe the steps undertaken for intiial differential expression analysis, with the goal of producing:
1. Normalized counts
2. Principal component analysis
3. Significantly diferentially expressed gene lists
  
This data was then exported as .CSV files and used in **[morpheus](https://software.broadinstitute.org/morpheus/) to generate heatmaps** in *1B* and *1E* and **[biovenn](https://www.biovenn.nl/index.php) for Venn diagram generation** in *1D*.
  
##DESeq2

Differential expression analysis using DESEQ2

There are 3 objects required for DESeq to run properly.

1. A *Counts* matrix, with one 1 set of labels (Ensembl ID in this case) as the row name

2. A *Design factor* with 1 level per treatment, and repetitions = n

3. A *colData* data frame containing a column reflecting the design

### Data and meta data

#### Counts matrix

```{r}
library(DESeq2)

Counts <-read.delim(paste0(in_path,"raw_counts.csv"), header = TRUE, row.names = 1, sep = ",")

Counts <- as.matrix(Counts[,1:48])

head(Counts)
```

#### Meta Data
    In this case, I have generated the function which allows for a few preset analyses of interest so as to keep the       global environment neat.

```{r}

#Possible comparison types: all_groups, fibro, inflam, angio, single *IF SINGLE MUST ALSO IDENTIFY TREATMENT*

metadatapicker <- function(comparisontype, treatment = NULL){

  
  
  if(comparisontype == "important"){
    condition <- factor(c(rep("Control", 6), rep("TGFb2", 6), rep("TNFa", 6), rep("Thrombin", 6), rep("cocktail", 6)))
    coldata <- data.frame(condition)
    coldata$condition <- relevel(coldata$condition, ref = "Control")
    
    # All Condition ---------------------------------------------------------
  
    }else if (comparisontype == "all"){
    
    condition <- factor(c(rep("Control", 6), rep("TGFb1", 6), rep("TGFb2", 6), rep("TNFa", 6), rep("Thrombin", 6) , rep("IL6", 6), rep("VEGF", 6), rep("cocktail", 6)))
    coldata <- data.frame(condition)
    coldata$condition <- relevel(coldata$condition, ref = "Control")    
    
    # Fibro Condition ---------------------------------------------------------
  
    }else if (comparisontype == "fibro"){
    
    condition <- factor(c(rep("Control", 6), rep("TGFb1", 6), rep("TGFb2", 6), rep("TNFa", 6), rep("Thrombin", 6)))
    coldata <- data.frame(condition)
    coldata$condition <- relevel(coldata$condition, ref = "Control")   
    
    # Inflam Condition --------------------------------------------------------
  
    }else if (comparisontype == "inflam"){
    
    condition <- factor(c(rep("Control", 6), rep("TGFb1", 6), rep("TNFa", 6), rep("Thrombin", 6) , rep("IL6", 6)))
    coldata <- data.frame(condition)
    coldata$condition <- relevel(coldata$condition, ref = "Control")    
    
    # Angio Condition ---------------------------------------------------------
  
    }else if (comparisontype == "angio"){
    
    condition <- factor(c(rep("Control", 6), rep("TGFb2", 6), rep("Thrombin", 6) ,rep("VEGF", 6)))
    coldata <- data.frame(condition)
    coldata$condition <- relevel(coldata$condition, ref = "Control")    
    
    # Individuals only (no cocktail) ---------------------------------------------------------
    
    }else if (comparisontype == "individuals"){
    condition <- factor(c(rep("Control", 6), rep("TGFb1", 6), rep("TGFb2", 6), rep("TNFa", 6), rep("Thrombin", 6) , rep("IL6", 6), rep("VEGF", 6)))
    coldata <- data.frame(condition)
    coldata$condition <- relevel(coldata$condition, ref = "Control")
    
    
    # Single Comparison Condition ---------------------------------------------
  
    }else if (comparisontype == "single"){
    
      if(!is.null(treatment)){
      condition <- factor(c(rep("Control", 6), rep(treatment, 6)))
      coldata <- data.frame(condition)
      coldata$condition <- relevel(coldata$condition, ref = "Control")
    
      }else{
      print("Please select a treatment for your single comparison. Returning only Control group in data frame")
        }
  
      }else{
    print("Invalid selection. Please choose from the list of possible comparisons.")
    return(NULL)
  }
  
  return(list("condition" = condition, "coldata" = coldata))

}
```

Use function to set meta data 
allows: all, individuals, fibro, inflam, angio and single* 
  *single comparisons requires selection of the treatment of interest


assign a list for the meta data objects and split this list to give a condition factor and coldata dataframe object
```{r}
metadata <- metadatapicker(comparisontype = "all",
                         treatment =
                          ) %>%
               list2env(.GlobalEnv)
```

##### Condition factor

```{r}
levels(condition)
```

##### colData data frame

```{r}
unique(coldata)
```

### Data Cleaning

Next, it is best practice to clean the data to remove any NA values, or unusable counts.
For this I have used the WGCNA package goodSamplesGenes function.

```{r}

library(WGCNA, quietly = TRUE) #Weighted Gene Co-expression Analysis package containing GoodSamplesGenes check

ddsCounts <- Counts #create duplicate of Counts before manipulating counts

gsg <- goodSamplesGenes(t(ddsCounts))
summary(gsg)


gsg$allOK #false in all ok indicates NA Values/iterative 0 values

table(gsg$goodGenes) # individual gene check (iterative check for repeated 0 values)?

table(gsg$goodSamples) #sample check

ddsCounts <- ddsCounts[gsg$goodGenes == TRUE, gsg$goodSamples == TRUE] #omit bad genes


```
### Run DESeq2

```{r}
dds <- DESeqDataSetFromMatrix(countData = ddsCounts, colData = coldata, design= ~condition)

dds <- DESeq(dds)
res <- results(dds) #results object
nrow(res) #number of genes examined

head(res) #structure of results

normcounts <- as.data.frame(counts(dds, normalized = TRUE)) #exportable normalised counts

avg_ncounts <- sapply(seq(1, ncol(normcounts), 6), function(j) rowMeans(normcounts[,j+(0:(5))])) %>% #sequences along columns and averages every 6 columns
  as.data.frame()%>% #represents the result as a dataframe
  set_colnames(levels(condition)) #sets the column names to match the levels of condition


vsdata <- vst(dds, blind= FALSE) #variance stablising transformation for PCA
vscounts <- assay(vsdata) #varaince stabilised counts



```

## Principal Component Analysis



### Load Necessary Packages
```{r}

library(RColorBrewer) #color palettes
library(ggplot2) #plotting package
library(ggrepel) #text and point repel
library(svglite) #save SVGs
```


### Plot PCA in ggplot

Generate PCA

```{r}
PCA <- plotPCA(vsdata, intgroup = "condition")+
  theme_bw()+ #base theme
  coord_equal(3)+ #set a plot size
  labs(title = "Figure 1A", color = "Condition")+ #labels
  theme(plot.title = element_text(hjust=0.5,vjust = 1.5, size = 20, face = "bold", color = "black"), 
        legend.title = element_text(size=14), legend.text = element_text(size=14),
        legend.margin = margin(0.2, 0.2, 0.2, 0.2, "cm"),
        legend.spacing = unit(2, "cm"),
        legend.key.size = unit(1.2, "lines"),
        legend.background = element_rect(fill = ,linewidth = 1, linetype ="solid", colour = "darkgrey"))

PCA
```
Further style changes were made in an external vector editor to increase figure legibility, these include:
- Adding of ellipses bounding points
- Adjustments to color scheme
- Omission of cocktail group


### Numerical PCA

This test is only really exploratory, and is best applied when performing a single comparison
```{r}

pca <- prcomp(t(vscounts))
pca.dat <- pca$x
#variance as standard deviation squared
pca.var <- pca$sdev^2
#percentage of explained variance
pca.var.percent <- round(pca.var/sum(pca.var)*100, digits = 2)
pca.var.percent
#convert to dataframe so its usable
pca.dat <- as.data.frame(pca.dat)
#plot an ugly PCA?
ggplot(pca.dat, aes(PC1, PC2)) +
  geom_point(aes(size = 5)) +
  geom_text(label = rownames(pca.dat)) +
  labs(x = paste0('PC1: ', pca.var.percent[1], ' %'),
       y = paste0('PC2: ', pca.var.percent[2], ' %'),
  )

kruskal.test(pca.dat$PC1 ~ condition)
kruskal.test(pca.dat$PC2 ~ condition) 


```


